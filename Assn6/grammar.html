<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
</head>
<body>
<h1><a href="http://www.cs.orst.edu/%7Ebudd/480.html">CS 480:</a>
Translators</h1>
<h1>Winter Term: 2011, Professor Budd</h1>
<h1>Grammar for Programming Assignments</h1>
<p>
The language we will use as the source for our compiler is
designed to be a simple yet realistic language.
The language has been specially constructed so that tokens can be
recognized by a lexical analyzer with one symbol lookahead, and
parsed using a LL(1) recognizer. Nevertheless, the language includes a
number of interesting features, such as classes,
functions, type declarations, and pointer values.
</p>
<p>In the following, literal tokens are shown in <b>bold</b>,
nonliteral
tokens in <i>italic</i>.
Curly braces are used to indicate repetition zero or more times.
The symbol &#949; is used to indicate nothing, the absence of tokens.
</p>
<h2>Program Structure</h2>
<table>
  <tbody>
    <tr>
      <td>program</td>
      <td>::=</td>
      <td>{ declaration ; } </td>
    </tr>
    <tr>
      <td>declaration</td>
      <td>::=</td>
      <td>classDeclaration </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>nonClassDeclaration </td>
    </tr>
    <tr>
      <td>nonClassDeclaration</td>
      <td>::=</td>
      <td>functionDeclaration </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>nonFunctionDeclaration </td>
    </tr>
    <tr>
      <td>nonFunctionDeclaration</td>
      <td>::=</td>
      <td>variableDeclaration </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>constantDeclaration </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>typeDeclaration </td>
    </tr>
    <tr>
      <td>constantDeclaration</td>
      <td>::=</td>
      <td><b>const</b> <i>identifier</i> = <i>constant</i> </td>
    </tr>
    <tr>
      <td>typeDeclaration</td>
      <td>::=</td>
      <td><b>type</b> nameDeclaration </td>
    </tr>
    <tr>
      <td>variableDeclaration</td>
      <td>::=</td>
      <td><b>var</b> nameDeclaration </td>
    </tr>
    <tr>
      <td>nameDeclaration</td>
      <td>::=</td>
      <td><i>identifier</i> <b>:</b> type </td>
    </tr>
  </tbody>
</table>
<p>
A program is a sequence of declarations. There are five types of
declarations, constants, types, variables, classes, and functions.
Constants must represent values known at compile time.
</p>
<h2>Classes and Functions</h2>
<table>
  <tbody>
    <tr>
      <td>classDeclaration</td>
      <td>::=</td>
      <td><b>class</b> <i>identifier</i> classBody </td>
    </tr>
    <tr>
      <td>classBody</td>
      <td>::=</td>
      <td><b>begin</b> { nonClassDeclaration ; } <b>end</b> </td>
    </tr>
    <tr>
      <td>functionDeclaration</td>
      <td>::=</td>
      <td><b>function</b> <i>identifier</i> arguments returnType
functionBody </td>
    </tr>
    <tr>
      <td>arguments</td>
      <td>::=</td>
      <td>( argumentList ) </td>
    </tr>
    <tr>
      <td>argumentList</td>
      <td>::=</td>
      <td>nameDeclaration { , nameDeclaration } </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>&#949; </td>
    </tr>
    <tr>
      <td>returnType</td>
      <td>::=</td>
      <td><b>:</b> type </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>&#949; </td>
    </tr>
    <tr>
      <td>type</td>
      <td>::=</td>
      <td><i>identifier</i> </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>^ type </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td><b>[</b> <i>integer</i> <b>:</b> <i>integer</i> <b>]</b>
type </td>
    </tr>
    <tr>
      <td>functionBody</td>
      <td>::=</td>
      <td>{ nonClassDeclaration ; } compoundStatement </td>
    </tr>
  </tbody>
</table>
<p>
A class creates a new type name and a name scope. Classes can contain
both data
fields and member functions. Functions can define optional return
values.
A function body consists of zero or more declarations followed by
a compound statement.
The identifier in the type nonterminal must represent a class name, or
a defined type name. The latter can be a predefined type (
<b>int</b>, or <b>real</b>) or a name that has appeared
earlier in a type declaration.
The ^ operator in a type declaration indicates a pointer type.
</p>
<h2>Statements</h2>
<table>
  <tbody>
    <tr>
      <td>compoundStatement</td>
      <td>::=</td>
      <td><b>begin</b> { statement <span style="font-weight: bold;">; </span>}
      <b>end</b> </td>
    </tr>
    <tr>
      <td>statement</td>
      <td>::=</td>
      <td>returnStatement </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>ifStatement </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>whileStatement </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>compoundStatement </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>assignOrFunction </td>
    </tr>
    <tr>
      <td>returnStatement</td>
      <td>::=</td>
      <td><b>return </b></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td><b>return</b> ( expression ) <br>
      </td>
    </tr>
    <tr>
      <td>ifStatement</td>
      <td>::=</td>
      <td><b>if</b>&nbsp; expression &nbsp; <b>then</b> statement </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td><b>if</b>&nbsp; expression <b>then</b> statement <span
 style="font-weight: bold;"></span><b>else</b>
statement </td>
    </tr>
    <tr>
      <td>whileStatement</td>
      <td>::=</td>
      <td><b>while</b>&nbsp; expression <b>do</b> statement </td>
    </tr>
    <tr>
      <td>assignOrFunction</td>
      <td>::=</td>
      <td>reference <b>=</b> expression </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>reference ( parameterList ) </td>
    </tr>
    <tr>
      <td>parameterList</td>
      <td>::=</td>
      <td>expression { , expression } </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>&#949; </td>
    </tr>
  </tbody>
</table>
<p>
There are six different types of statements. The <b>else</b> clause in
an <b>if</b> <b>else</b> statement always joins with the closest
surrounding <b>if</b> statement.
The value in the return statement must match the type of the
surrounding
function declaration. The expressions in the test portions of the if or
while
statements must be boolean. The expression on the right side of an
assignment
must be either integer, floating point, or pointer type.
</p>
<h2>Expressions</h2>
<table>
  <tbody>
    <tr>
      <td>expression</td>
      <td>::=</td>
      <td>relExpression { <i>logicalOperator</i> relExpression } </td>
    </tr>
    <tr>
      <td>relExpression</td>
      <td>::=</td>
      <td>plusExpression </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>plusExpression <i>relationalOperator</i> plusExpression </td>
    </tr>
    <tr>
      <td>plusExpression</td>
      <td>::=</td>
      <td>timesExpression { <i> additionOperator</i> timesExpression }
      </td>
    </tr>
    <tr>
      <td>timesExpression</td>
      <td>::=</td>
      <td>term { <i>multiplicationOperator</i> term } </td>
    </tr>
    <tr>
      <td>term</td>
      <td>::=</td>
      <td>( expression ) </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td><b>not</b> term<br>
      </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td><b>new</b> type<br>
      </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td><b>-</b> term </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>reference </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td><b>&amp;</b> reference </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>reference ( parameterList ) </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td><i>constant</i> </td>
    </tr>
    <tr>
      <td>reference</td>
      <td>::=</td>
      <td><i>identifier</i> </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>reference ^ </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>reference <b>.</b> <i>identifier</i> </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td>|</td>
      <td>reference [ expression ] </td>
    </tr>
  </tbody>
</table>
<p>The new operator returns pointer to a heap-based value.&nbsp; (We
have no delete operator, so memory is not recovered). The constant
types are integer, real and string.
The ampresand operator returns the address of the corresponding
reference.
The ^ symbol used as an operator on a reference dereferences a pointer
value.
The dot notation is used to access both data fields and member
functions
in a class structure.
</p>
<h2>Lexical Conventions</h2>
<ol>
  <li>Comments are surrounded by { and }.
They may not contain either a { or a }.
Comments may appear anyplace but within a token. </li>
  <li>Blanks between tokens are optional, with the exception that
keywords cannot
be immediately adjacent to identifiers. </li>
  <li>The <i>identifier</i> token matches a letter followed by letters
or digits. </li>
  <li>There are three constant types. An integer constant is a sequence
of one or more digits, interpreted as a base-10 value. A floating point
constant is a sequence of one or more digits, followed by
a period, followed by zero or more digits.
A string constant is surrounded by a pair of double quotes, and cannot
contain
a double quote character. </li>
  <li>Keywords are reserved, and cannot be used as variable names. </li>
  <li>The logical operators are <b>and</b> and <b>or</b>. </li>
  <li>The legal relational tests are &lt; &lt;= !=, ==, &gt;= and &gt; </li>
  <li>The legal addition operators are + and -, and &lt;&lt;. The
latter is the left shift operator, and requires two integer arguments. </li>
  <li>The legal multiplication operators are * and / and %. The latter
is
the remainder operator, and requires two integer arguments. </li>
  <li>Arguments are passed by value. Legal arguments must be integer,
floating
point, or pointer type. </li>
  <li>Arithmetic operations on integer arguments return integer values.
If both arguments are floating point the result if floating point.
If one argument is integer and other other floating point, the integer
argument is converted to floating point and the result is floating
point. </li>
  <li>Relational and logical operators return a value of type boolean. </li>
  <li>The lower bound in a declaration of any array type must be less
than the upper bound. </li>
  <li>In a field expression, the identifier must match one of the
declared field
names. </li>
  <li>All variables and functions must be declared prior to their first
use. </li>
</ol>
</body>
</html>
